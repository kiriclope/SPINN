<#+STARTUP: fold
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session lif_single :kernel dual_data
# #+PROPERTY: header-args:ipython :results both :exports both :async yes :session /ssh:172.26.20.46:~/.local/share/jupyter/runtime/kernel-343f5c4f-82fe-4da8-aa26-6dafafa92f96.json :kernel dual_data

* Notebook utils
** Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run /home/leon/models/lif_cpp/notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/dual_data/bin/python

** Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '/home/leon/models/lif_cpp')  
  REPO_PATH = "/home/leon/models/lif_cpp"

  import subprocess
  import pandas as pd
  from time import sleep
  from yaml import safe_load
  from scipy.stats import circmean
  from run_model import run_cpp, update_conf, restore_conf
  from analysis.decode import decode_bump, circcvl  
  pal = [sns.color_palette("tab10")[0], sns.color_palette("tab10")[1]]
#+end_src

#+RESULTS:

** Helpers

#+begin_src ipython
  def run_sim(conf_name, session, X_str=None, axis=0, gain=1, IF_M0=1):

    restore_conf(REPO_PATH + '/conf/' + conf_name + '.yml',
                 REPO_PATH + '/conf/'+ conf_name +'.yml.bak')

    config = safe_load(open("/home/leon/models/lif_cpp/conf/"+ conf_name +".yml", "r"))

    conf_path = REPO_PATH + '/conf/' + conf_name + '.yml'
    data_path = REPO_PATH + '/data/simul/' + session
    update_conf(REPO_PATH + '/conf/' + conf_name, 'DATA_PATH', data_path)
    if X_str is not None:
      if axis is not None:
        update_conf(REPO_PATH + '/conf/' + conf_name, X_str, float(config[X_str][axis] * gain), axis=axis)
      elif axis == -1:
        for axis in range(np.array(config[X_str]).shape[0]):
          update_conf(REPO_PATH + '/conf/' + conf_name, X_str, float(config[X_str][axis] * gain), axis=axis)          
      else:
        update_conf(REPO_PATH + '/conf/' + conf_name, X_str, float(config[X_str]) * gain, axis=None)

    if IF_M0:
      update_conf(REPO_PATH + '/conf/' + conf_name, 'Iext', float(config['Iext'][0] * 1.1), axis=0)

    update_conf(REPO_PATH + '/conf/' + conf_name, 'T_SAVE', float(0.0), axis=None)
    update_conf(REPO_PATH + '/conf/' + conf_name, 'DURATION', float(20000.0), axis=None)
    update_conf(REPO_PATH + '/conf/' + conf_name, 'T_STEADY', float(10000.0), axis=None)
    
    sleep(.2)
    run_cpp(session, conf_path=conf_path)
    sleep(.2)

    restore_conf(REPO_PATH + '/conf/' + conf_name + '.yml.bak',
                 REPO_PATH + '/conf/'+ conf_name +'.yml')
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_data(session='/'):
    # Open the file in binary mode and read the data
    with open('/home/leon/models/lif_cpp/data/simul/'+ session + '/rates.txt', 'rb') as f:
      data = np.fromfile(f, dtype=np.float32)
    # Now 'data' is a numpy array containing your data
    return data.reshape(-1, 40000).T
 #+end_src

 #+RESULTS:

#+begin_src ipython
  def get_times(conf_name):
       config = safe_load(open("/home/leon/models/lif_cpp/conf/"+conf_name+".yml", "r"))

       times = np.arange(0, 20000, config['T_WINDOW'])
       # times -= config['T_STEADY']
       times /= 1000.0

       return times
#+end_src

#+RESULTS:
** Compilation
#+begin_src sh
  cd $HOME/models/lif_cpp
  make clean
  make
#+end_src

#+RESULTS:
| rm  | -rf   | ./obj/*.o    | ./bin/LifNet  |                   |               |                  |                  |             |                      |                           |               |                |                     |             |                      |                           |            |
| g++ | -Wall | -std=c++17   | -Ofast        | -s                | -march=native | -funroll-loops   | -ftree-vectorize | -ffast-math | -fomit-frame-pointer | -fexpensive-optimizations | -lyaml-cpp    | -c             | src/globals.cpp     | -o          | obj/globals.o        |                           |            |
| g++ | -Wall | -std=c++17   | -Ofast        | -s                | -march=native | -funroll-loops   | -ftree-vectorize | -ffast-math | -fomit-frame-pointer | -fexpensive-optimizations | -lyaml-cpp    | -c             | src/lif_network.cpp | -o          | obj/lif_network.o    |                           |            |
| g++ | -Wall | -std=c++17   | -Ofast        | -s                | -march=native | -funroll-loops   | -ftree-vectorize | -ffast-math | -fomit-frame-pointer | -fexpensive-optimizations | -lyaml-cpp    | -c             | src/main.cpp        | -o          | obj/main.o           |                           |            |
| g++ | -Wall | -std=c++17   | -Ofast        | -s                | -march=native | -funroll-loops   | -ftree-vectorize | -ffast-math | -fomit-frame-pointer | -fexpensive-optimizations | -lyaml-cpp    | -c             | src/sparse_mat.cpp  | -o          | obj/sparse_mat.o     |                           |            |
| g++ | -o    | ./bin/LifNet | obj/globals.o | obj/lif_network.o | obj/main.o    | obj/sparse_mat.o | -Wall            | -std=c++17  | -Ofast               | -s                        | -march=native | -funroll-loops | -ftree-vectorize    | -ffast-math | -fomit-frame-pointer | -fexpensive-optimizations | -lyaml-cpp |

* Single trial
** Simulation

#+begin_src ipython
  conf_name = 'config'
  config = safe_load(open("/home/leon/models/lif_cpp/conf/"+ conf_name +".yml", "r"))

  N_E = int(config['N'] * 0.8)
  N_I = int(config['N'] * 0.2)

  print(N_E)
  Iext = np.array(config['Iext'])
  Jab = np.array(config['Jab'])

  BALANCE = ((Iext[0] / Jab[0]) / (Iext[1] / Jab[2])) > ((Jab[1] / Jab[0]) / (Jab[3] / Jab[2]))
  print('Balance', BALANCE)

  # BALANCE = (Iext[0] / Iext[1]) > (Jab[1] / Jab[3])
  # print(BALANCE)

  rates = -np.dot(np.linalg.inv(Jab.reshape((2 ,2))), Iext)
  print('rates', rates)

  J = Jab[1] * Jab[2] / (Jab[0] * Jab[3])
  Q = (Jab[3] * Jab[1] * Iext[0] - Iext[1]) / Jab[2]

  # print('stp G', J)
  # print('stp Q', Q)
#+end_src

#+RESULTS:
: 32000
: Balance True
: rates [-0.21346887  1.47395172]

#+begin_src ipython
  session = 'odr_off'
  run_sim(conf_name, session, X_str='Iext', gain=1.0, axis=0)
#+end_src

#+RESULTS:

#+begin_src ipython 
  session = 'odr_on'
  run_sim(conf_name, session, X_str='Iext', gain=1.1, axis=0)
#+end_src

#+RESULTS:

** Analysis
*** Rates

#+begin_src ipython
  session = 'odr_off'
  data_off = get_data(session)
  print('data', data_off.shape)
  rates_off = data_off[:N_E]
  print('rates', np.mean(data_off[:N_E]), np.mean(data_off[N_E:]))
#+end_src

#+RESULTS:
: data (40000, 79)
: rates 6.2022104 11.918247

#+begin_src ipython  
  session = 'odr_on'
  data_on = get_data(session)
  print('data', data_on.shape)
  rates_on = data_on[:N_E]
  print('rates', np.mean(data_on[:N_E]), np.mean(data_on[N_E:]))
#+end_src

#+RESULTS:
: data (40000, 79)
: rates 6.210101 11.9302025

#+begin_src ipython
  width = 7
  golden_ratio = (5**.5 - 1) / 2
  fig, ax = plt.subplots(1, 2, figsize= [1.5*width, width * golden_ratio])

  r_min = 0
  r_max = 1.25 * np.max((np.mean(rates_off), np.mean(rates_on)))

  times = get_times(conf_name)
  times_off = times[:data_off.shape[1]]
  times_on = times[:data_on.shape[1]]

  im = ax[0].imshow(rates_off, aspect='auto', cmap='jet',vmin=0, vmax=r_max, extent=[times_off[0], times_off[-1], 0, N_E])

  ax[0].set_xlabel('Time (s)')
  ax[0].set_xticks(np.arange(int(times_off[0]), int(times_off[-1]), 2))
  ax[0].set_ylabel('Prefered Location (°)')
  ax[0].set_yticks([0, N_E/4, N_E/2, 3*N_E/4, N_E], [0, 90, 180, 270, 360])
  ax[0].set_title('Control')

  im = ax[1].imshow(rates_on, aspect='auto', cmap='jet',vmin=0, vmax=r_max, extent=[times_on[0], times_on[-1], 0, N_E])

  ax[1].set_xlabel('Time (s)')
  # ax[1].set_xticks([0, 1, 2, 3, 4, 5])
  ax[1].set_xticks(np.arange(int(times_on[0]), int(times_on[-1]), 2))
  ax[1].set_yticks([0, N_E/4, N_E/2, 3*N_E/4, N_E], [0, 90, 180, 270, 360])
  ax[1].set_title('NB Stim')

  # fig.subplots_adjust(right=0.85)  # Create space on the right side of the subplots

  # Define the new axis for the colorbar
  # cbar_ax = fig.add_axes([1.0, 0.25, 0.02, 0.6])  # This adds a new axes for the colorbar
  # [left, bottom, width, height] in normalized (0,1) units

  # Create the colorbar in the new axes
  # cbar = fig.colorbar(im, cax=cbar_ax)

  # cbar = plt.colorbar(im, ax=ax.ravel().tolist(), pad=0.2)
  # cbar = fig.colorbar(im, ax=ax, orientation='vertical', pad=0.1)
  # cbar.set_label("Firing Rate (Hz)")
  # cbar.set_ticks([0, 2, 4, 6, 8])
  # plt.savefig('./neurons.svg', dpi=300)
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/1d446cb1d4bdb63a86bd8ea7808ce61fdbd9294f.png]]

*** Fourier vs Time

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_off, axis=0)
  m0_on, m1_on, phi_on = decode_bump(rates_on, axis=0)

  times = get_times(conf_name)
  times_off = times[:data_off.shape[1]]
  times_on = times[:data_on.shape[1]]
  
  fig, ax = plt.subplots(1, 3, figsize=(2*width, height))
  ax[0].plot(times_off, m0)
  ax[0].plot(times_on, m0_on)

  ax[0].set_xlabel('Time (s)')
  ax[0].set_ylabel('$\mathcal{F}^0$ (Hz)')
  # ax[0].set_xticks([0, 1, 2, 3, 4, 5])
  ax[0].set_ylim([0, r_max])

  ax[1].plot(times_off, m1 / m0)
  ax[1].plot(times_on, m1_on / m0_on)

  ax[1].set_xlabel('Time (s)')
  ax[1].set_ylabel('$\mathcal{F}^1 / \mathcal{F}^0$')
  # ax[1].set_xticks([0, 1, 2, 3, 4, 5])

  ax[2].plot(times_off, phi * 180 / np.pi)
  ax[2].plot(times_on, phi_on * 180 / np.pi)

  ax[2].set_xlabel('Time (s)')
  ax[2].set_ylabel('$\phi$ (°)')
  ax[2].set_yticks([-180, -90, 0, 90, 180], [0, 90, 180, 270, 360])
  # ax[2].set_xticks([0, 1, 2, 3, 4, 5])
  plt.tight_layout()
  plt.show()
  #+end_src

#+RESULTS:
[[file:./.ob-jupyter/75311c9606a2f140811ff3c6e7a7e3ae1e6a3dc4.png]]

*** Spatial profile

#+begin_src ipython
  smooth_off = circcvl(rates_off, windowSize=640, axis=0)
  smooth_on = circcvl(rates_on, windowSize=640, axis=0)

  m0, m1, phase = decode_bump(smooth_off[:, -1])
  smooth_off = np.roll(smooth_off[:, -1], int((phase / 2.0 / np.pi - 0.5) * smooth_off.shape[0]))

  theta = np.linspace(0, 360, rates_off.shape[0])
  plt.plot(theta, m0 + m1 * np.cos(theta * np.pi / 180- np.pi), 'b')
  plt.plot(theta, smooth_off, 'b', label='off')
  
  m0, m1, phase =decode_bump(smooth_on[:, -1])
  smooth_on = np.roll(smooth_on[:, -1], int((phase / 2.0 / np.pi - 0.5) * smooth_on.shape[0]))

  plt.plot(theta, smooth_on, 'r', label='on')
  plt.plot(theta, m0 + m1 * np.cos(theta * np.pi / 180- np.pi), 'r')

  plt.xlabel('Prefered Location (°)')
  plt.ylabel('Rate (Hz)')
  plt.legend(frameon=0, fontsize=12)
  # plt.yticks([5, 10])
  plt.xticks([0, 90, 180, 270, 360]);
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/ca8070e32133e0eb153b466cc075a984fa722ea7.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

